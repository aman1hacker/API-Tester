<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Aman API Tester</title>
  <style>
    /* --- visual styles (your original aesthetic) --- */
    :root{
      --accent1: #FF6B6B;
      --accent2: #4ECDC4;
      --card-bg: rgba(255,255,255,0.06);
      --glass: rgba(255,255,255,0.08);
    }
    body {
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      max-width: 920px;
      margin: 0 auto;
      padding: 24px;
      background: linear-gradient(135deg,#667eea 0%,#764ba2 100%);
      min-height: 100vh;
      color: #fff;
      -webkit-font-smoothing:antialiased;
    }
    .container {
      background: rgba(255,255,255,0.06);
      padding: 28px;
      border-radius: 16px;
      backdrop-filter: blur(8px);
      box-shadow: 0 8px 32px rgba(31,38,135,0.28);
    }
    h1 { text-align:center; margin:0 0 18px; font-size:26px; }
    .test-section { margin-bottom:18px; padding:16px; background:var(--card-bg); border-radius:10px; border:1px solid rgba(255,255,255,0.06); }
    .controls { display:flex; gap:8px; flex-wrap:wrap; }
    button {
      background: linear-gradient(45deg,var(--accent1),var(--accent2));
      color:white; border:none; padding:10px 18px; border-radius:20px; cursor:pointer; font-weight:700;
      box-shadow: 0 6px 18px rgba(0,0,0,0.2);
    }
    button.secondary { background:transparent; border:1px solid rgba(255,255,255,0.12); }
    button:disabled { opacity:0.5; cursor:not-allowed; transform:none; box-shadow:none; }
    input, textarea { width:100%; padding:10px; border-radius:8px; border:none; margin-top:10px; background: rgba(255,255,255,0.04); color:#fff; }
    .result { margin-top:12px; padding:12px; background: rgba(0,0,0,0.28); border-radius:8px; max-height:340px; overflow:auto; white-space:pre-wrap; border:1px solid rgba(255,255,255,0.06); }
    .status-grid { display:grid; grid-template-columns:repeat(auto-fit,minmax(200px,1fr)); gap:12px; margin-top:12px; }
    .status-card{ padding:12px; border-radius:10px; background:rgba(255,255,255,0.03); text-align:center; border:1px solid rgba(255,255,255,0.05); }
    .ok { color:#9ef3d0; } .err { color:#ffcccb; }
    .tiny { font-size:13px; opacity:0.85; }
    label.switch{display:inline-flex;align-items:center;gap:8px}
    .live-dot{display:inline-block;width:10px;height:10px;border-radius:50%;}
    .live-on{background:#4ECDC4;} .live-off{background:#FF6B6B;}
  </style>
</head>
<body>
  <div class="container">
    <h1>🚀 Aman API Tester</h1>

    <!-- ---------- API Status Check ---------- -->
    <div class="test-section" id="statusSection">
      <strong>📊 API Status Check</strong>
      <div class="controls" style="margin-top:12px;">
        <button id="btnCheck">Check Status</button>
        <button id="btnReset" class="secondary">Reset All Keys</button>
        <label class="switch tiny" style="margin-left:auto;">
          <input type="checkbox" id="liveToggle" />
          <span class="tiny">Live status</span>
        </label>
      </div>
      <div class="status-grid" style="margin-top:12px;">
        <div class="status-card">
          <div class="tiny">Endpoint</div>
          <div id="endpoint" class="tiny">—</div>
        </div>
        <div class="status-card">
          <div class="tiny">Last Result</div>
          <div id="lastResult" class="tiny">—</div>
        </div>
        <div class="status-card">
          <div class="tiny">Latency</div>
          <div id="latency" class="tiny">—</div>
        </div>
        <div class="status-card">
          <div class="tiny">Live</div>
          <div id="liveDot" class="tiny"><span class="live-dot live-off"></span></div>
        </div>
      </div>
      <div id="statusMsg" class="result" style="margin-top:12px;">Ready.</div>
    </div>

    <!-- ---------- Message Test ---------- -->
    <div class="test-section">
      <strong>💬 Message Test</strong>
      <textarea id="prompt" rows="3" placeholder="Type test prompt (eg. Hello, OpenRouter!)">Hello, how are you?</textarea>
      <div class="controls">
        <button id="btnSend">Send Message</button>
        <button id="btnShort" class="secondary">Short Example</button>
        <button id="btnLong" class="secondary">Long Example</button>
      </div>
      <div id="sendResult" class="result">No request yet.</div>
    </div>

    <!-- ---------- Quick Tests ---------- -->
    <div class="test-section">
      <strong>⚡ Quick Tests</strong>
      <div style="margin-top:8px;" class="controls">
        <button data-test="hindi" class="quick">Hindi Test</button>
        <button data-test="english" class="quick">English Test</button>
        <button data-test="long" class="quick">Long Message Test</button>
        <button id="rapidFire" class="secondary">Rapid Fire (5)</button>
      </div>
      <div id="quickResult" class="result">No quick tests run.</div>
    </div>

    <!-- ---------- Live API status ---------- -->
    <div class="test-section">
      <strong>🔴 Live API Status</strong>
      <div class="tiny" style="margin-top:8px;">
        This will poll the endpoint every 30s when Live is toggled ON. If you get `Network Error` or `CORS` errors,
        enable CORS on your Render endpoint or run a small proxy (see notes below).
      </div>
    </div>

  </div>

<script>
/* ---------- CONFIG ---------- */
const RENDER_URL = 'https://api-zd2s.onrender.com/gemini'; // <- your render endpoint
const REQUEST_TIMEOUT = 10000; // ms
let liveInterval = null;

/* ---------- UTIL: fetch with timeout ---------- */
async function fetchWithTimeout(url, opts = {}, timeout = REQUEST_TIMEOUT){
  const controller = new AbortController();
  const id = setTimeout(() => controller.abort(), timeout);
  try {
    const res = await fetch(url, {...opts, signal: controller.signal});
    clearTimeout(id);
    return res;
  } catch (err) {
    clearTimeout(id);
    throw err;
  }
}

/* ---------- UI refs ---------- */
const btnCheck = document.getElementById('btnCheck');
const btnReset = document.getElementById('btnReset');
const liveToggle = document.getElementById('liveToggle');
const endpointEl = document.getElementById('endpoint');
const lastResultEl = document.getElementById('lastResult');
const latencyEl = document.getElementById('latency');
const liveDot = document.querySelector('.live-dot');
const statusMsg = document.getElementById('statusMsg');
const promptEl = document.getElementById('prompt');
const btnSend = document.getElementById('btnSend');
const sendResult = document.getElementById('sendResult');
const quickResult = document.getElementById('quickResult');
const quickButtons = document.querySelectorAll('.quick');
const rapidFireBtn = document.getElementById('rapidFire');
const btnShort = document.getElementById('btnShort');
const btnLong = document.getElementById('btnLong');

/* ---------- CORE: call render endpoint ---------- */
async function callRender(prompt){
  // payload structure expected by your server: { message: "..." }
  const body = JSON.stringify({ message: prompt });
  const start = Date.now();
  const res = await fetchWithTimeout(RENDER_URL, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body
  }, REQUEST_TIMEOUT);
  const latency = Date.now() - start;
  // try parse as json, fallback to text
  const ctype = res.headers.get('content-type') || '';
  let data;
  if (ctype.includes('application/json')) data = await res.json();
  else data = await res.text();
  return { status: res.status, data, latency };
}

/* ---------- STATUS CHECK ---------- */
async function doStatusCheck(){
  endpointEl.textContent = RENDER_URL;
  statusMsg.textContent = 'Checking...';
  lastResultEl.textContent = 'Checking';
  latencyEl.textContent = '—';
  try {
    const start = Date.now();
    // use small prompt to check
    const r = await callRender('status check');
    const latency = r.latency;
    latencyEl.textContent = latency + ' ms';
    lastResultEl.textContent = (r.status >= 200 && r.status < 300) ? 'OK' : ('HTTP ' + r.status);
    statusMsg.textContent = 'Response:\n' + (typeof r.data === 'string' ? r.data : JSON.stringify(r.data, null, 2));
    liveDot.className = 'live-dot ' + ((r.status >= 200 && r.status < 300) ? 'live-on' : 'live-off');
  } catch (err) {
    console.error(err);
    lastResultEl.textContent = 'Error';
    latencyEl.textContent = '—';
    statusMsg.textContent = '❌ Error: ' + (err.name === 'AbortError' ? 'Request timed out' : (err.message || err));
    liveDot.className = 'live-dot live-off';
  }
}

/* ---------- SEND Message ---------- */
async function sendMessage(){
  const prompt = promptEl.value.trim();
  if (!prompt) { sendResult.textContent = 'Please type a prompt.'; return; }
  sendResult.textContent = 'Sending...';
  btnSend.disabled = true;
  try {
    const r = await callRender(prompt);
    if (r.status >= 200 && r.status < 300) {
      // common render response shape earlier was { reply: '...' } or plain text
      let out = '';
      if (r.data && typeof r.data === 'object') out = JSON.stringify(r.data, null, 2);
      else out = String(r.data);
      sendResult.textContent = `Status: ${r.status}\nLatency: ${r.latency} ms\n\n${out}`;
    } else {
      sendResult.textContent = `HTTP ${r.status}\n\n${JSON.stringify(r.data, null, 2)}`;
    }
  } catch (err) {
    sendResult.textContent = '❌ Network / CORS / Timeout error: ' + (err.name === 'AbortError' ? 'Timeout' : err.message || err);
  } finally {
    btnSend.disabled = false;
  }
}

/* ---------- QUICK TESTS ---------- */
async function runQuick(kind){
  quickResult.textContent = `Running ${kind} test...`;
  let prompt = '';
  if (kind === 'hindi') prompt = 'Namaste! Kaise ho? (Short friendly Hindi reply)';
  if (kind === 'english') prompt = 'Hello! How are you? (Short friendly English reply)';
  if (kind === 'long') prompt = 'Write a friendly, slightly long message (4-5 sentences) about daily motivation.';
  try {
    const r = await callRender(prompt);
    quickResult.textContent = (r.status >= 200 && r.status < 300) ? (`Latency ${r.latency} ms\n\n` + (typeof r.data === 'string' ? r.data : JSON.stringify(r.data, null, 2))) : (`HTTP ${r.status}\n\n${JSON.stringify(r.data, null, 2)}`);
  } catch (err) {
    quickResult.textContent = '❌ Error: ' + (err.name === 'AbortError' ? 'Timeout' : err.message || err);
  }
}

/* ---------- RAPID FIRE ---------- */
async function rapidFire(n=5){
  quickResult.textContent = 'Rapid fire starting...';
  rapidFireBtn.disabled = true;
  const results = [];
  for (let i=0;i<n;i++){
    try {
      const r = await callRender(`rapid test ${i+1}`);
      results.push({i:i+1, ok: r.status>=200 && r.status<300, status: r.status, latency: r.latency, data: r.data});
    } catch (err) {
      results.push({i:i+1, ok:false, error: err.message || String(err)});
    }
  }
  rapidFireBtn.disabled = false;
  quickResult.textContent = results.map(r => r.ok ? `#${r.i} OK ${r.latency}ms` : `#${r.i} ERR ${r.error||r.status}`).join('\n');
}

/* ---------- RESET KEYS (client-side placeholder) ---------- */
function resetAllKeys(){
  localStorage.clear();
  alert('Local keys cleared (client-side). If you store keys server-side, reset them on server.');
}

/* ---------- LIVE POLLING ---------- */
function setLive(enabled){
  if (enabled){
    doStatusCheck();
    liveInterval = setInterval(doStatusCheck, 30000);
    liveDot.className = 'live-dot live-on';
  } else {
    if (liveInterval) clearInterval(liveInterval);
    liveDot.className = 'live-dot live-off';
  }
}

/* ---------- Hook events ---------- */
btnCheck.addEventListener('click', doStatusCheck);
btnReset.addEventListener('click', resetAllKeys);
btnSend.addEventListener('click', sendMessage);
btnShort.addEventListener('click', ()=>{ promptEl.value = 'Hello! Short friendly reply please.'; });
btnLong.addEventListener('click', ()=>{ promptEl.value = 'Write a warm motivational paragraph (3-4 lines) for the evening.'; });
quickButtons.forEach(b => b.addEventListener('click', (e)=> runQuick(e.currentTarget.dataset.test)));
rapidFireBtn.addEventListener('click', ()=> rapidFire(5));
liveToggle.addEventListener('change', (e)=> setLive(e.target.checked));

/* ---------- initial quick status ---------- */
endpointEl.textContent = RENDER_URL;
lastResultEl.textContent = '—';
latencyEl.textContent = '—';
statusMsg.textContent = 'Ready. Click "Check Status" to test the Render endpoint.';

/* ---------- NOTES for you (not UI) ----------
  1) If browser shows `NetworkError` or `CORS` in console:
     - Enable CORS on your server or add allowed origin (`*` for testing) on Render app.
     - Example (Node/Express): app.use(cors({ origin: '*' }))
     - Or create a tiny proxy on your server that forwards to your /gemini endpoint.

  2) Server expects POST JSON { message: "..." } — page sends that format.

  3) If server returns JSON like { reply: "..."} we show the JSON. You can adapt parsing to show reply field only.

  4) If you want "Reset All Keys" to contact your server to rotate keys, change resetAllKeys() to call server endpoint.

  5) To debug CORS, open browser console (F12) and watch network request + response headers.

---------------------------------------------- */
</script>
</body>
</html>
